#include "chunk.h"

// TODO int    load_all(FILE *Stream, Chunks *chunks); 
// TODO Chunks allocChunks(size_t cap, size_t amount); 
// TODO int    chunks_dump(FILE *Stream, Chunks *chunks); 

void NOT_IMPLEMENTED(void)
{
    printf("%s IS NOT NOT IMPLEMENTED", __func__);

} 
   
Chunks *load_all(FILE *Stream)
{  	
	// Allocate mem for the whole file.
	
	// The size of the whole file.
	


	long size = get_file_size(Stream);
	printf("full size: %lu\n", size);
	// The remaining size if we devide by 1024 byte.
	size_t rem = (size % CHUNK_SIZE);
	// The qoutient
	size_t q = (size - rem);
	
	// The amount of chunks we need to allocate.
	size_t chunkAmount = (q / CHUNK_SIZE);

	if(rem > 0) chunkAmount++;
	
	printf("Alloc chunks: %zu\n", chunkAmount);

	Chunks *chunks = allocChunks(0, chunkAmount);
	
	int code;

	for(size_t i = 0; i < chunkAmount; i++)
	{
		// TODO: Bug in Reading.
		// TODO: Fix the Loader, so it does not overflow.
		// INFO: the loader loads one chunk only :/
		
		code = load(Stream, chunks->items + i);
		
		// if chunks.size == chunks.cap then the memory that was perviously allocated is full.
		if(code == 0) 
		{
			printf("exit code: %i\n", code);
			break;
		}

		chunks->size++; //
	}


	return chunks;
}

int chunks_dump(FILE *Stream, Chunks *chunks)
{  


	(void) Stream;
	(void) chunks;
	NOT_IMPLEMENTED();
    return 0;  
}

/*

Chunks allocChunks(size_t cap, size_t amount)
{  
    NOT_IMPLEMENTED();
    return 0;  
}  

*/ 
       
  
long get_file_size(FILE *Stream) 
{
    fseek(Stream, 0L, SEEK_END);
    long size = ftell(Stream);
    fseek(Stream, 0L, SEEK_SET);
    return size;
}

Chunk load_chunk(FILE *Stream)
{    

    Chunk *chunk = allocChunk(0);
    
    size_t size = fread(chunk->bytes, 1, chunk->cap, Stream);
    chunk->size = size;
    return *chunk;
}

int load(FILE *Stream, Chunk *chunk)
{ 
    size_t s = fread(chunk->bytes, 1, chunk->cap, Stream);      
    chunk->size = s; 

	printf("T");
	printf("size: %zu\n", chunk->size);


	return s;
}

int chunk_dump(FILE *Stream, Chunk *chunk)
{
    if(Stream == NULL)
    {
		return 1;
    }
    
    fwrite(chunk->bytes, 1, chunk->size, Stream);  
    return 0;
}

void report_usage(Chunk *chunk)
{
    printf("[!] Last chunk size: %zu\n", chunk->size);
    printf("[!] used chunk capacity: %zu\n", chunk->cap);
}

Chunk *allocChunk(size_t cap)
{
    if(cap == 0)
    {
		cap = CHUNK_SIZE;
    }

    Chunk *chunk = malloc(sizeof(Chunk));
    chunk->cap   = cap;
    chunk->size  = 0;    
    chunk->bytes = calloc(cap, sizeof(void));
    // Tested using malloc and memset and it does not set all the values. which is weird!

    // chunk->bytes = malloc(cap);
    // memset(chunk->bytes, 0, chunk->cap);
    
    return chunk;

}

Chunks *allocChunks(size_t cap, size_t amount)
{
	// So chunks is empty from garbage values
	
	Chunks *chunks = calloc(1, sizeof(Chunks));	
	chunks->cap   = amount;

    if(cap == 0) cap = CHUNK_SIZE;
    
    chunks->items = (void *) malloc(sizeof(Chunk) * amount);
    

    for(; amount > 0; amount--)
    {
        Chunk *C = chunks->items + (amount - 1);

		(C)->bytes = calloc(cap, sizeof(void));
		(C)->cap   = cap;
		(C)->size  = 0;

		chunks->size++;	
    }

    // Tested using malloc and memset and it does not set all the values. which is weird!
    // chunk->bytes = malloc(cap);
    // memset(chunk->bytes, 0, chunk->cap);
    
    return chunks;

}
